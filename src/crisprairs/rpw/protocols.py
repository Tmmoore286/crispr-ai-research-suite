"""Generate markdown protocols from a completed session context."""

from __future__ import annotations

from datetime import datetime, timezone

from crisprairs.engine.context import SessionContext

REAGENT_CATALOG = {
    "SpCas9": {
        "plasmid": "Addgene #42230 (pX330-U6-Chimeric_BB-CBh-hSpCas9)",
        "protein": "IDT Alt-R S.p. Cas9 Nuclease V3 (Cat# 1081058)",
        "tracrRNA": "IDT Alt-R CRISPR-Cas9 tracrRNA (Cat# 1072532)",
    },
    "SaCas9": {
        "plasmid": "Addgene #61591 (pX601-AAV-CMV::NLS-SaCas9-NLS-3xHA-bGHpA)",
        "protein": "IDT Alt-R S.a. Cas9 Nuclease (Cat# 10006502)",
    },
    "enCas12a": {
        "plasmid": "Addgene #132416 (pCMV-T7-enAsCas12a-HF1)",
        "protein": "IDT Alt-R A.s. Cas12a (Cpf1) Ultra (Cat# 10001272)",
    },
    "SpRYCas9": {
        "plasmid": "Addgene #139987 (pCMV-T7-SpRY-P2A-EGFP)",
    },
    "CBE": {
        "plasmid": "Addgene #110396 (pCMV-BE4max)",
        "description": "Cytosine base editor",
    },
    "ABE": {
        "plasmid": "Addgene #112098 (pCMV-ABE7.10)",
        "description": "Adenine base editor",
    },
    "PE2": {
        "plasmid": "Addgene #132775 (pCMV-PE2)",
        "description": "Prime editor 2",
    },
    "PE3": {
        "plasmid": "Addgene #132775 (pCMV-PE2) + nicking sgRNA",
        "description": "Prime editor 3",
    },
    "dCas9-VP64": {
        "plasmid": "Addgene #61422 (pAC94-pmax-dCas9VP160-2A-puro)",
        "description": "Activation effector",
    },
    "dCas9-KRAB": {
        "plasmid": "Addgene #110820 (pLV-dCas9-KRAB-PuroR)",
        "description": "Repression effector",
    },
    "common": {
        "transfection": "Lipofectamine 3000 (Thermo Fisher Cat# L3000001)",
        "electroporation": "Lonza 4D-Nucleofector (Cat# AAF-1003B)",
        "culture_medium": "DMEM + 10% FBS + 1% Pen/Strep",
        "puromycin": "Puromycin dihydrochloride (Sigma Cat# P8833)",
        "T7E1": "T7 Endonuclease I (NEB Cat# M0302S)",
    },
}

_EDITING_MODALITIES = {"Knockout", "Base Editing", "Prime Editing", "CRISPRa/CRISPRi"}


class ProtocolGenerator:
    """Convert session context into a report-style markdown protocol."""

    @classmethod
    def generate(cls, ctx: SessionContext, session_id: str | None = None) -> str:
        modality = cls._resolve_modality(ctx)
        cas = ctx.cas_system or "Not specified"
        gene = ctx.target_gene or "Not specified"
        species = ctx.species or "Not specified"
        delivery_method = ctx.delivery.method or "Not specified"
        delivery_format = ctx.delivery.format or "Not specified"
        delivery_product = ctx.delivery.product or ""

        lines: list[str] = []
        lines.extend(cls._header_block(session_id, gene, species, cas, modality))

        if delivery_method != "Not specified":
            lines.extend(
                [
                    f"**Delivery Method:** {delivery_method}",
                    f"**Delivery Format:** {delivery_format}",
                    "",
                ]
            )

        lines.extend(cls._materials_block(cas))
        lines.append("")
        lines.extend(cls._guide_block(ctx))
        lines.append("")

        if modality in _EDITING_MODALITIES:
            lines.extend(
                cls._editing_steps_block(
                    modality=modality,
                    cas=cas,
                    gene=gene,
                    delivery_method=delivery_method,
                    delivery_format=delivery_format,
                    delivery_product=delivery_product,
                )
            )
            lines.append("")
            lines.extend(cls._controls_block(modality))
            lines.append("")
            lines.extend(cls._expected_block(modality))
        elif modality == "Off-Target Analysis":
            lines.extend(cls._off_target_block(ctx))
        elif modality == "Troubleshooting":
            lines.extend(cls._troubleshooting_block(ctx))
        else:
            lines.extend(cls._generic_summary_block())

        lines.extend(["", "---", "", "*Generated by CRISPR AI Research Suite Protocol Export.*"])
        return "\n".join(lines)

    @classmethod
    def _resolve_modality(cls, ctx: SessionContext) -> str:
        raw = (ctx.modality or "").lower()
        if "base" in raw:
            return "Base Editing"
        if "prime" in raw:
            return "Prime Editing"
        if raw in {"activation", "repression"}:
            return "CRISPRa/CRISPRi"
        if raw == "off_target":
            return "Off-Target Analysis"
        if raw == "troubleshoot":
            return "Troubleshooting"
        return "Knockout"

    @staticmethod
    def _header_block(session_id, gene, species, cas, modality) -> list[str]:
        today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
        block = [
            "# CRISPR Experiment Protocol",
            "",
            f"**Date Generated:** {today}",
        ]
        if session_id:
            block.append(f"**Session ID:** {session_id}")
        block.extend(
            [
                f"**Target Gene:** {gene}",
                f"**Species:** {species}",
                f"**CRISPR System:** {cas}",
                f"**Modality:** {modality}",
                "",
                "---",
                "",
            ]
        )
        return block

    @staticmethod
    def _materials_block(cas: str) -> list[str]:
        lines = ["## Materials", "", "### CRISPR Components"]
        cas_reagents = REAGENT_CATALOG.get(cas, {})
        if cas_reagents:
            for key, value in cas_reagents.items():
                if key == "description":
                    continue
                lines.append(f"- **{key.replace('_', ' ').title()}:** {value}")
        else:
            lines.append(f"- {cas} reagents: consult modality-specific literature")

        lines.extend(["", "### General Reagents"])
        for key, value in REAGENT_CATALOG["common"].items():
            lines.append(f"- **{key.replace('_', ' ').title()}:** {value}")
        return lines

    @staticmethod
    def _guide_block(ctx: SessionContext) -> list[str]:
        if not ctx.guides:
            return ["## sgRNA Sequences", "", "*No sgRNA data available from this session.*"]

        lines = ["## sgRNA Sequences", "", "| # | Sequence | Score | Source |", "|---|----------|-------|--------|"]
        for i, guide in enumerate(ctx.guides, start=1):
            lines.append(f"| {i} | `{guide.sequence}` | {guide.score:.1f} | {guide.source} |")
        return lines

    @classmethod
    def _editing_steps_block(
        cls,
        modality: str,
        cas: str,
        gene: str,
        delivery_method: str,
        delivery_format: str,
        delivery_product: str,
    ) -> list[str]:
        lines = [
            "## Experimental Steps",
            "",
            "### 1. Construct Preparation",
            f"- Prepare guide constructs or RNAs compatible with {cas}",
            "- Confirm sequence identity before delivery",
            "",
            "### 2. Cell Preparation",
            "- Culture cells/tissue model under recommended conditions",
            "- Start delivery at suitable confluency or density",
            "",
            "### 3. Delivery",
        ]

        lines.extend(cls._delivery_steps(delivery_method, delivery_format, delivery_product, cas))
        lines.extend(
            [
                "- Include a no-treatment control well/group",
                "",
                "### 4. Selection (if applicable)",
                "- Apply selection marker only if the system requires it",
                "- Maintain selection window long enough for recovery",
                "",
                "### 5. Validation",
            ]
        )

        if modality == "Knockout":
            lines.extend(
                [
                    "- Amplify target locus after editing window",
                    f"- Confirm disruption at the {gene} site via T7E1 or sequencing",
                    "- Validate protein loss where relevant",
                ]
            )
        elif modality == "Base Editing":
            lines.extend(
                [
                    "- Sequence amplicons to quantify base conversion",
                    "- Use EditR or CRISPResso2 for conversion analysis",
                    "- Check for bystander edits within the editing window",
                ]
            )
        elif modality == "Prime Editing":
            lines.extend(
                [
                    "- Use deep sequencing to verify exact edit installation",
                    "- Quantify intended edits and byproducts with CRISPResso2",
                    "- Compare pegRNA/nicking variants if multiple were tested",
                ]
            )
        elif modality == "CRISPRa/CRISPRi":
            lines.extend(
                [
                    "- Measure transcript changes by RT-qPCR",
                    "- Normalize to stable housekeeping controls",
                    "- Optionally validate at protein level",
                ]
            )

        return lines

    @staticmethod
    def _delivery_steps(method: str, fmt: str, product: str, cas: str) -> list[str]:
        lines: list[str] = []

        if method == "lipofection":
            reagent = product or "Lipofectamine 3000"
            lines.append(f"- Deliver payload using {reagent}")
            if fmt == "RNP":
                lines.append("- Pre-assemble RNP complex before transfection")
            else:
                lines.append(f"- Use plasmid setup compatible with {cas}")
            return lines

        if method == "electroporation":
            device = product or "Lonza 4D-Nucleofector"
            lines.append(f"- Electroporate using {device}")
            if fmt == "RNP":
                lines.append("- Use RNP complexing prior to pulse")
            else:
                lines.append("- Use plasmid/mRNA-compatible pulse conditions")
            lines.append("- Apply a cell-type validated program")
            return lines

        if method == "lentiviral":
            return [
                "- Package and titer lentiviral particles",
                "- Transduce at controlled MOI and include integration controls",
            ]

        if method == "AAV":
            serotype = product or "AAV"
            return [
                f"- Prepare {serotype} payload with size-compatible editor design",
                "- Dose according to tissue and study design constraints",
            ]

        if method == "LNP":
            lines.append(f"- Formulate {fmt} cargo in LNP platform")
            lines.append("- Run dose-finding for target tissue response")
            return lines

        return ["- Choose an appropriate delivery method for the model system"]

    @staticmethod
    def _controls_block(modality: str) -> list[str]:
        controls = [
            "## Controls",
            "",
            "- **Negative control:** non-targeting guide",
            "- **Untreated control:** no editor delivery",
        ]
        if modality == "Knockout":
            controls.append("- **Positive control:** validated knockout guide")
        elif modality in {"Base Editing", "Prime Editing"}:
            controls.append("- **Positive control:** validated editable locus")
        elif modality == "CRISPRa/CRISPRi":
            controls.append("- **Positive control:** known responsive regulation target")
        return controls

    @staticmethod
    def _expected_block(modality: str) -> list[str]:
        lines = ["## Expected Results", ""]
        if modality == "Knockout":
            lines.extend(
                [
                    "- Indel evidence should appear at the target locus",
                    "- Editing efficiency commonly ranges from moderate to high depending on model",
                    "- Functional protein reduction should track genotype where applicable",
                ]
            )
        elif modality == "Base Editing":
            lines.extend(
                [
                    "- Detectable base conversion at intended position",
                    "- Base conversion levels vary with guide placement and editor choice",
                    "- Typically fewer indels than nuclease-mediated knockout",
                ]
            )
        elif modality == "Prime Editing":
            lines.extend(
                [
                    "- Deep sequencing should reveal precise edit outcomes",
                    "- Efficiency is sensitive to pegRNA and nicking strategy",
                    "- Byproduct profiles should be quantified per design arm",
                ]
            )
        elif modality == "CRISPRa/CRISPRi":
            lines.extend(
                [
                    "- RT-qPCR should show directional expression shifts",
                    "- Effect magnitude depends on guide placement and effector architecture",
                ]
            )
        return lines

    @staticmethod
    def _off_target_block(ctx: SessionContext) -> list[str]:
        lines = [
            "## Analysis Summary",
            "",
            "### 1. Specificity Review",
            "- Review MIT specificity and predicted off-target burden per guide",
            "",
            "### 2. Risk Triage",
            "- Classify guides as low/medium/high risk and prioritize safer candidates",
        ]
        if ctx.off_target_results:
            lines.extend(["", "### 3. Guide Recommendations"])
            for record in ctx.off_target_results:
                guide = record.get("guide_name", "Guide")
                risk = record.get("risk_level", "unknown")
                rec = record.get("recommendation", "")
                lines.append(f"- **{guide}**: {risk.upper()} risk. {rec}")
        return lines

    @staticmethod
    def _troubleshooting_block(ctx: SessionContext) -> list[str]:
        issue = ctx.troubleshoot_issue or "unspecified"
        lines = [
            "## Troubleshooting Summary",
            "",
            "### 1. Issue Classification",
            f"- Reported issue category: **{issue}**",
            "",
            "### 2. Prioritized Actions",
        ]
        if ctx.troubleshoot_recommendations:
            for i, action in enumerate(ctx.troubleshoot_recommendations, start=1):
                lines.append(f"- {i}. {action}")
        else:
            lines.append("- No troubleshooting actions were recorded for this session.")
        return lines

    @staticmethod
    def _generic_summary_block() -> list[str]:
        return [
            "## Session Summary",
            "",
            "- This session does not map to a protocol template with experimental steps.",
        ]
